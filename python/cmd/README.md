# intro
suppose you want to make a comand line tool called cmd.
it accept integer as numbers
ouput carrots we need to feed
```
ex:
	cmd> cmd 2 
	ouput: 4
```

we can get the output by two ways:
- command line
	```bash
	 cmd  2
	```

- call python moudle 
  ``` bash
  python -m cmd 2
  ```



# best practice schema 
##  env 
Generated by `make env`

This is first step you need to do in any python project
- it will create a virtual env
- auto source it 
- install requirements for the start up

## test 
run `make test`


## run
`make run ` will run in module mode 
`make main` will run in normal mode


You can see that `main.py` and `cmd/__main__.py` are the same  content file.

why do we need `main.py` ? 
It is eay to make an  entry in IDE , like intellij.


Could I just use `__main__.py` to run  like this?
``` bash
python cmd/__main__.py
```
You cound not.

That is because the top-level package problem.

Ex:
```
python main.py 
top-level package is the same as main.py

python src/func/main.py  
top-level package is the same as main.py, aka func 
top-level package is the folder where you run this command from
```

So , why `cmd/__main__.py` does not work?

because top-level package is cmd now.


## logging 
system logging is so hard to use it right. 
use https://github.com/Delgan/loguru

## make module
  update readmeput moudle in the folder parallel with logx folder.

  - logx 
  - your_module


## packing module or cmd

###  local 
for quick test purpose
- install: `pip install .` 
- uninstall: `pip uninstall <module_name>`

> make install
> make uninstall


### upload to test or prod PYPI server 
upload to test server:
```
make upload-to-test 
```

upload to prod server:
```
make upload-to-prod
```

### test and coverage 

#### pure test
```
make test
```

#### test with coverage
```
make coverage
```


# used packge
[pysnooper](https://github.com/cool-rr/pysnooper)
